/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.recipe.quarkus.internal;

import org.jetbrains.annotations.NotNull;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.function.BiPredicate;
import java.util.regex.Pattern;

import static java.util.Comparator.*;
import static java.util.function.Predicate.not;
import static java.util.stream.Collectors.*;

@NullMarked
public class AggregateQuarkusUpdates {


    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: java AggregateQuarkusUpdates <path to quarkus-updates recipes> <path to consolidated recipes>");
        }

        Path quarkusRecipesDirectory = Path.of(args[0]);
        Path consolidatedRecipe = Path.of(args[1]);

        System.out.printf("Starting aggregation of Quarkus update recipes from %s to %s%n", quarkusRecipesDirectory.toAbsolutePath(), consolidatedRecipe.toAbsolutePath());

        if (!quarkusRecipesDirectory.toFile().exists()) {
            throw new IllegalStateException("quarkusio/quarkus-updates.git is not available under 'quarkus-updates', please clone here temporarily");
        }

        System.out.printf("Reading recipes from %s%n", quarkusRecipesDirectory.toAbsolutePath());
        SortedMap<Version, Set<String>> sortedByVersion = recipesDefinedInQuarkusRepo(quarkusRecipesDirectory);

        System.out.printf(
          "Found %s different versions and %s recipes in total%n",
          sortedByVersion.size(),
          sortedByVersion.values().stream().mapToInt(Set::size).sum());

        StringBuilder recipeYml = new StringBuilder();
        recipeYml.append("""
          #
          # Copyright 2025 the original author or authors.
          # <p>
          # Licensed under the Apache License, Version 2.0 (the "License");
          # you may not use this file except in compliance with the License.
          # You may obtain a copy of the License at
          # <p>
          # https://www.apache.org/licenses/LICENSE-2.0
          # <p>
          # Unless required by applicable law or agreed to in writing, software
          # distributed under the License is distributed on an "AS IS" BASIS,
          # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
          # See the License for the specific language governing permissions and
          # limitations under the License.
          #
          # This file is auto-generated by running `./gradlew generateQuarkusAggregation` from the "Generate Quarkus aggregation recipes" workflow
          """);
        Version prior = null;
        for (Map.Entry<Version, Set<String>> entry : sortedByVersion.entrySet()) {
            Version current = entry.getKey();
            Set<String> recipes = entry.getValue();

            if (recipes.isEmpty()) {
                continue;
            }

            System.out.printf("\t%s has %d recipes%n", current, recipes.size());
            recipeYml.append(createRecipe(current, prior, recipes));
            prior = current;
        }

        try {
            Files.writeString(consolidatedRecipe, recipeYml);
            System.out.printf("Wrote aggregating recipes to %s", consolidatedRecipe.toAbsolutePath());
        } catch (IOException e) {
            System.err.printf("Failed to write to %s due to %s", consolidatedRecipe.toAbsolutePath(), e.getMessage());
        }

    }

    private static SortedMap<Version, Set<String>> recipesDefinedInQuarkusRepo(Path quarkusRecipesDirectory) {
        BiPredicate<Path, BasicFileAttributes> yamlFileFilter = (p, a) -> p.getFileName().toString().endsWith(".yml") || p.getFileName().toString().endsWith(".yaml");
        try (var recipesFiles = Files.find(quarkusRecipesDirectory, 3, yamlFileFilter)) {
            return recipesFiles.collect(toMap(
              p -> Version.parse(p.getFileName().toString()),
              AggregateQuarkusUpdates::extractRecipeVersions,
              (a, b) -> {
                  a.addAll(b);
                  return a;
              },
              java.util.TreeMap::new));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /// Normalize recipe name for a given version
    static String recipeNameFor(Version version) {
        if (version.patch == null || version.patch.startsWith("alpha")) {
            return "org.openrewrite.quarkus.MigrateToQuarkus_v%s_%s".formatted(version.major, version.minor);
        }

        return "org.openrewrite.quarkus.MigrateToQuarkus_v%s_%s_%s".formatted(version.major, version.minor, version.patch);
    }

    /// Create a recipe that aggregates all the given recipes for a specific version, optionally including the prior version's recipe as well.
    static String createRecipe(Version version, @Nullable Version priorVersion, Set<String> recipeList) {
        return
          // language=YAML
          """
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: %s
            displayName: Quarkus Updates Aggregate %s
            description: Quarkus update recipes to upgrade your application to %s.
            recipeList:%s%s
            """.formatted(
            recipeNameFor(version),
            version,
            version,
            priorVersion != null ? "\n  - " + recipeNameFor(priorVersion) : "",
            recipeList.stream().collect(joining("\n  - ", "\n  - ", "\n")));
    }

    /// Parse the defined recipe names from a given file using `type: specs.openrewrite.org/v1beta/recipe\nname: ([\.\w]*)``
    static Set<String> extractRecipeVersions(Path file) {
        Pattern compile = Pattern.compile("type: specs.openrewrite.org/v1beta/recipe\\nname: ([.\\w]*)");
        try {
            return compile.matcher(Files.readString(file))
              .results()
              .map(r -> r.group(1))
              .filter(not("io.quarkus.updates.minio.minio38.UpdateProperties"::equals)) // Exclude this one as it is a duplicate
              .collect(toSet());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    record Version(int major, int minor, @Nullable String patch) implements Comparable<Version> {
        /**
         * The recipe name of a Quarkus update recipe contains the target version.
         */
        public static Version parse(String version) {
            if ("3alpha.yaml".equals(version)) {
                // Special case for the initial Quarkus 3 alpha recipe
                return new Version(3, 0, "alpha");
            }

            String[] parts = version.split("\\.");
            int major = Integer.parseInt(parts[0]);
            int minor = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;

            // handle cases like 2.13.yaml
            if (parts.length < 3 || Objects.equals(parts[2], "yaml")) {
                return new Version(major, minor, null);
            }

            // handle cases like 2.13.0.yaml or 2.13.alpha1.yaml
            return new Version(major, minor, parts[2]);
        }

        private static final Comparator<Version> versionComparator = comparing(Version::major).thenComparing(Version::minor).thenComparing(Version::patch, nullsFirst(naturalOrder()));
        @Override
        public int compareTo(Version other) {
            return versionComparator.compare(this, other);
        }

        @Override
        public String toString() {
            return (patch == null || patch.startsWith("alpha")) ?
                "%s.%s".formatted(major, minor) :
                "%s.%s.%s".formatted(major, minor, patch);
        }
    }
}
