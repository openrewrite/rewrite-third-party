/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.recipe.quarkus.internal;

import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.function.BiPredicate;
import java.util.regex.MatchResult;
import java.util.regex.Pattern;

import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.toSet;

@NullMarked
public class AggregateQuarkusUpdates {

    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.out.println("Usage: java AggregateQuarkusUpdates <path to quarkus-updates recipes> <path to consolidated recipes>");
        }

        Path quarkusRecipesDirectory = Path.of(args[0]);
        Path consolidatedRecipe = Path.of(args[1]);

        System.out.printf("Starting aggregation of Quarkus update recipes from %s to %s%n", quarkusRecipesDirectory.toAbsolutePath(), consolidatedRecipe.toAbsolutePath());

        if (!quarkusRecipesDirectory.toFile().exists()) {
            throw new IllegalStateException("quarkusio/quarkus-updates.git is not available under 'quarkus-updates', please clone here temporarily");
        }

        System.out.printf("Reading recipes from %s%n", quarkusRecipesDirectory.toAbsolutePath());
        Map<Version, List<String>> sortedByVersion = recipesDefinedInQuarkusRepo(quarkusRecipesDirectory);

        System.out.printf(
          "Found %s different versions and %s recipes in total%n",
          sortedByVersion.size(),
          sortedByVersion.values().stream().mapToInt(List::size).sum());

        StringBuilder recipeYml = new StringBuilder();
        recipeYml.append("""
          #
          # Copyright 2025 the original author or authors.
          # <p>
          # Licensed under the Apache License, Version 2.0 (the "License");
          # you may not use this file except in compliance with the License.
          # You may obtain a copy of the License at
          # <p>
          # https://www.apache.org/licenses/LICENSE-2.0
          # <p>
          # Unless required by applicable law or agreed to in writing, software
          # distributed under the License is distributed on an "AS IS" BASIS,
          # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
          # See the License for the specific language governing permissions and
          # limitations under the License.
          #
          # This file is auto-generated by running `./gradlew generateQuarkusAggregation` from the "Generate Quarkus aggregation recipes" workflow
          """);

        List<Version> versions = new ArrayList<>(sortedByVersion.keySet());
        versions.sort(Version::compareTo);
        Version prior = null;
        for (Version current : versions) {
            List<String> recipes = sortedByVersion.get(current);

            if (recipes.isEmpty()) {
                continue;
            }

            System.out.printf("\t%s has %d recipes%n", current, recipes.size());
            recipeYml.append(createRecipe(current, prior, recipes));
            prior = current;
        }

        try {
            Files.writeString(consolidatedRecipe, recipeYml);
            System.out.printf("Wrote aggregating recipes to %s", consolidatedRecipe.toAbsolutePath());
        } catch (IOException e) {
            System.err.printf("Failed to write to %s due to %s", consolidatedRecipe.toAbsolutePath(), e.getMessage());
        }

    }

    private static final BiPredicate<Path, BasicFileAttributes> yamlFileFilter = (p, a) -> p.getFileName().toString().endsWith(".yml") || p.getFileName().toString().endsWith(".yaml");

    static Map<Version, List<String>> recipesDefinedInQuarkusRepo(Path quarkusRecipesDirectory) throws IOException {
        Set<Path> recipesFiles = Files.find(quarkusRecipesDirectory, 3, yamlFileFilter).collect(toSet());
        Map<Version, List<String>> sortedByVersion = new HashMap<>();
        for (Path recipe : recipesFiles) {
            var version = Version.parse(recipe.getFileName().toString());
            var recipeNames = extractRecipeNames(recipe);
            sortedByVersion.computeIfAbsent(version, v -> new ArrayList<>()).addAll(recipeNames);
        }

        return sortedByVersion;
    }

    /// Normalize recipe name for a given version
    static String recipeNameFor(Version version) {
        return "org.openrewrite.quarkus.MigrateToQuarkus_v%s_%s_%s".formatted(version.major, version.minor, version.patch);
    }

    /// Create a recipe that aggregates all the given recipes for a specific version, optionally including the prior version's recipe as well.
    static String createRecipe(Version version, @Nullable Version priorVersion, List<String> recipeList) {
        return
          // language=YAML
          """
            ---
            type: specs.openrewrite.org/v1beta/recipe
            name: %s
            displayName: Quarkus Updates Aggregate %s
            description: Quarkus update recipes to upgrade your application to %s.
            recipeList:%s
              - %s

            """.formatted(
            recipeNameFor(version),
            version,
            version,
            priorVersion != null ? "\n  - " + recipeNameFor(priorVersion) : "",
            String.join("\n  - ", recipeList));
    }

    /// Parse the defined recipe names from a given file using `type: specs.openrewrite.org/v1beta/recipe\nname: ([\.\w]*)``
    static List<String> extractRecipeNames(Path file) {
        Pattern compile = Pattern.compile("type: specs.openrewrite.org/v1beta/recipe\\nname: ([.\\w]*)");
        try {
            List<String> recipeNames = new ArrayList<>();
            for (MatchResult recipeNamesResults : compile.matcher(Files.readString(file)).results().toList()) {
                String recipeName = recipeNamesResults.group(1);
                if ("io.quarkus.updates.minio.minio38.UpdateProperties".equals(recipeName)) {
                    continue;
                }
                recipeNames.add(recipeName);
            }
            return List.copyOf(recipeNames);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    record Version(int major, int minor, Integer patch) implements Comparable<Version> {
        /**
         * The recipe name of a Quarkus update recipe contains the target version.
         */
        public static Version parse(String version) {
            if ("3alpha.yaml".equals(version)) {
                // Special case for the initial Quarkus 3 alpha recipe
                return new Version(3, 0, 0);
            }

            String[] parts = version.split("\\.");
            int major = Integer.parseInt(parts[0]);
            int minor = parts.length > 1 ? Integer.parseInt(parts[1]) : 0;

            // handle cases like 2.13.yaml and fold to 2.13.0
            if (parts.length < 3
              || Objects.equals(parts[2], "yaml")
              // fold 2.13.alphaX.yaml into 2.13
              || parts[2].startsWith("alpha")) {
                return new Version(major, minor, 0);
            }

            // handle cases like 2.13.X.yaml
            return new Version(major, minor, Integer.parseInt(parts[2]));
        }

        private static final Comparator<Version> versionComparator = comparing(Version::major).thenComparing(Version::minor).thenComparing(Version::patch);

        @Override
        public int compareTo(Version other) {
            return versionComparator.compare(this, other);
        }

        @Override
        public String toString() {
            return "%s.%s.%s".formatted(major, minor, patch);
        }
    }
}
